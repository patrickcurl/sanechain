{"version":3,"file":"index.esm.mjs","sources":["../src/index.ts"],"sourcesContent":["import { ITSAndTypeAndStringLiteral, ITSTypeAndStringLiteral } from 'ts-type/lib/helper/string';\n\nexport const enum EnumLineBreak\n{\n\tCR = \"\\r\",\n\tCRLF = \"\\r\\n\",\n\tLF = \"\\n\",\n}\n\nexport const enum EnumLineBreakCharCode\n{\n\tCR = 0x0d,\n\tLF = 0x0a,\n}\n\nconst CR = EnumLineBreak.CR as const;\nconst CRLF = EnumLineBreak.CRLF as const;\nconst LF = EnumLineBreak.LF as const;\n\nconst R_CRLF = /\\r\\n|\\r(?!\\n)|\\n/g;\nconst R_CRLF_MATCH = new RegExp(`(${R_CRLF.source})`, R_CRLF.flags);\n\nexport { CR, CRLF, LF, R_CRLF, R_CRLF_MATCH }\n\nexport type ILineBreak = ITSTypeAndStringLiteral<EnumLineBreak>;\n\nexport type ILineBreakInput = ITSAndTypeAndStringLiteral<EnumLineBreak>;\n\nexport interface IOptions\n{\n\tdisable?: {\n\t\tlf?: boolean,\n\t\tcrlf?: boolean,\n\t\tcr?: boolean,\n\t}\n}\n\nexport function crlf(text: string, newline: ILineBreakInput = EnumLineBreak.LF): string\n{\n\treturn text.replace(R_CRLF, newline);\n}\n\nexport function chkcrlf(text: string, options?: IOptions)\n{\n\tconst disable = options?.disable ?? {};\n\n\treturn {\n\t\tlf: !disable.lf && /\\n/.test(text.replace(/\\r\\n/g, '')),\n\t\tcrlf: !disable.crlf && /\\r\\n/.test(text),\n\t\tcr: !disable.cr && /\\r(?!\\n)/.test(text),\n\t} as const;\n}\n\nexport type IChkCrlf = ReturnType<typeof chkcrlf>;\n\nexport function detectLineBreak(text: string, options?: IOptions)\n{\n\tconst _lb = chkcrlf(text, options);\n\treturn _detectLineBreakCore(_lb)\n}\n\nexport function _detectLineBreakCore(_lb: IChkCrlf)\n{\n\treturn _lb.crlf ? EnumLineBreak.CRLF : (_lb.lf || !_lb.cr) ? EnumLineBreak.LF : EnumLineBreak.CR\n}\n\nexport function isCRLF(newline: string): newline is EnumLineBreak.CRLF\n{\n\treturn newline === EnumLineBreak.CRLF\n}\n\nexport function isLF(newline: string): newline is EnumLineBreak.LF\n{\n\treturn newline === EnumLineBreak.LF\n}\n\nexport function isCR(newline: string): newline is EnumLineBreak.CR\n{\n\treturn newline === EnumLineBreak.CR\n}\n\nexport function charCodeIsLF(charCode: number): charCode is EnumLineBreakCharCode.LF\n{\n\treturn charCode === EnumLineBreakCharCode.LF\n}\n\nexport function charCodeIsCR(charCode: number): charCode is EnumLineBreakCharCode.CR\n{\n\treturn charCode === EnumLineBreakCharCode.CR\n}\n\nexport function lineSplit(text: string)\n{\n\treturn text.split(R_CRLF);\n}\n\nexport function crlf_unicode_normalize(text: string, newline: ILineBreakInput = EnumLineBreak.LF): string\n{\n\tconst ln3 = newline + newline + newline;\n\tconst ln2 = newline + newline;\n\n\treturn text\n\t\t.replace(/\\u000C/g, ln3)\n\t\t.replace(/\\u2028/g, newline)\n\t\t.replace(/\\u2029/g, ln2)\n\t\t;\n}\n\nexport function isEqualWithIgnoreLineSeparators(a: string, b: string)\n{\n\tconst _lb_a: IChkCrlf = chkcrlf(a);\n\tconst _lb_b: IChkCrlf = chkcrlf(b);\n\n\tlet bool = false;\n\n\tif (_lb_a.cr === _lb_b.cr && _lb_a.crlf === _lb_b.crlf && _lb_a.lf === _lb_b.lf)\n\t{\n\t\tbool = crlf(a) === crlf(b);\n\t}\n\n\treturn {\n\t\tbool,\n\t\t_lb_a,\n\t\t_lb_b,\n\t}\n}\n\nexport type ILineBreakName = keyof typeof EnumLineBreak;\n\nexport function toLineBreakName(newline: ILineBreakInput): ILineBreakName\n{\n\tswitch (newline)\n\t{\n\t\tcase EnumLineBreak.LF:\n\t\t\treturn 'LF'\n\t\tcase EnumLineBreak.CR:\n\t\t\treturn 'CR'\n\t\tcase EnumLineBreak.CRLF:\n\t\t\treturn 'CRLF'\n\t}\n\n\tthrow new TypeError(`Invalid line break`);\n}\n\nexport function nameToLineBreak(name: ILineBreakName | Lowercase<ILineBreakName> | Capitalize<Lowercase<ILineBreakName>> | string): EnumLineBreak\n{\n\tswitch (name?.toUpperCase())\n\t{\n\t\tcase 'LF':\n\t\t\treturn EnumLineBreak.LF\n\t\tcase 'CR':\n\t\t\treturn EnumLineBreak.CR\n\t\tcase 'CRLF':\n\t\t\treturn EnumLineBreak.CRLF\n\t}\n\n\tthrow new TypeError(`Invalid line break name: ${name}`);\n}\n\nexport function detectCurrentIndexLineBreakFromBufferLike<T extends number, A extends {\n\t[n: number]: number\n}>(buffer: A, index: T)\n{\n\tconst cur = buffer[index];\n\tconst next = index + 1;\n\tif (charCodeIsLF(cur))\n\t{\n\t\treturn {\n\t\t\tnewline: EnumLineBreak.LF as const,\n\t\t\tcur: cur as EnumLineBreakCharCode.LF,\n\t\t\tindex,\n\t\t\tnext,\n\t\t\tlength: 1 as const,\n\t\t} as const\n\t}\n\telse if (charCodeIsCR(cur))\n\t{\n\t\tif (charCodeIsLF(buffer[next]))\n\t\t{\n\t\t\treturn {\n\t\t\t\tnewline: EnumLineBreak.CRLF as const,\n\t\t\t\tcur: cur as EnumLineBreakCharCode.CR,\n\t\t\t\tindex,\n\t\t\t\tnext: next + 1,\n\t\t\t\tlength: 2 as const,\n\t\t\t} as const\n\t\t}\n\n\t\treturn {\n\t\t\tnewline: EnumLineBreak.CR as const,\n\t\t\tcur: cur as EnumLineBreakCharCode.CR,\n\t\t\tindex,\n\t\t\tnext,\n\t\t\tlength: 1 as const,\n\t\t} as const\n\t}\n\n\treturn {\n\t\tnewline: void 0 as undefined,\n\t\tcur,\n\t\tindex,\n\t\tnext,\n\t\tlength: 0 as const,\n\t} as const\n}\n\nexport function detectCurrentIndexLineBreak<T extends number, A extends {\n\t[n: number]: string\n}>(buffer: A, index: T)\n{\n\tconst cur = buffer[index];\n\tconst next = index + 1;\n\tif (isLF(cur))\n\t{\n\t\treturn {\n\t\t\tnewline: EnumLineBreak.LF as const,\n\t\t\tcur: cur as EnumLineBreak.LF,\n\t\t\tindex,\n\t\t\tnext,\n\t\t\tlength: 1 as const,\n\t\t} as const\n\t}\n\telse if (isCR(cur))\n\t{\n\t\tif (isLF(buffer[next]))\n\t\t{\n\t\t\treturn {\n\t\t\t\tnewline: EnumLineBreak.CRLF as const,\n\t\t\t\tcur: cur as EnumLineBreak.CR,\n\t\t\t\tindex,\n\t\t\t\tnext: next + 1,\n\t\t\t\tlength: 2 as const,\n\t\t\t} as const\n\t\t}\n\n\t\treturn {\n\t\t\tnewline: EnumLineBreak.CR as const,\n\t\t\tcur: cur as EnumLineBreak.CR,\n\t\t\tindex,\n\t\t\tnext,\n\t\t\tlength: 1 as const,\n\t\t} as const\n\t}\n\n\treturn {\n\t\tnewline: void 0 as void,\n\t\tcur,\n\t\tindex,\n\t\tnext,\n\t\tlength: 0 as const,\n\t} as const\n}\n\nexport default crlf;\n"],"names":["EnumLineBreak","EnumLineBreakCharCode","CR","CRLF","LF","R_CRLF","R_CRLF_MATCH","RegExp","source","flags","crlf","text","newline","replace","chkcrlf","options","_options$disable","disable","lf","test","cr","detectLineBreak","_detectLineBreakCore","_lb","isCRLF","isLF","isCR","charCodeIsLF","charCode","charCodeIsCR","lineSplit","split","crlf_unicode_normalize","ln2","isEqualWithIgnoreLineSeparators","a","b","_lb_a","_lb_b","bool","toLineBreakName","TypeError","nameToLineBreak","name","toUpperCase","detectCurrentIndexLineBreakFromBufferLike","buffer","index","cur","next","length","detectCurrentIndexLineBreak"],"mappings":"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"}