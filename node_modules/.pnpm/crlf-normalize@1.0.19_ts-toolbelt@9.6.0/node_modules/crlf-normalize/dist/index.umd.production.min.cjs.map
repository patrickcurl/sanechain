{"version":3,"file":"index.umd.production.min.cjs","sources":["../src/index.ts"],"sourcesContent":["import { ITSAndTypeAndStringLiteral, ITSTypeAndStringLiteral } from 'ts-type/lib/helper/string';\n\nexport const enum EnumLineBreak\n{\n\tCR = \"\\r\",\n\tCRLF = \"\\r\\n\",\n\tLF = \"\\n\",\n}\n\nexport const enum EnumLineBreakCharCode\n{\n\tCR = 0x0d,\n\tLF = 0x0a,\n}\n\nconst CR = EnumLineBreak.CR as const;\nconst CRLF = EnumLineBreak.CRLF as const;\nconst LF = EnumLineBreak.LF as const;\n\nconst R_CRLF = /\\r\\n|\\r(?!\\n)|\\n/g;\nconst R_CRLF_MATCH = new RegExp(`(${R_CRLF.source})`, R_CRLF.flags);\n\nexport { CR, CRLF, LF, R_CRLF, R_CRLF_MATCH }\n\nexport type ILineBreak = ITSTypeAndStringLiteral<EnumLineBreak>;\n\nexport type ILineBreakInput = ITSAndTypeAndStringLiteral<EnumLineBreak>;\n\nexport interface IOptions\n{\n\tdisable?: {\n\t\tlf?: boolean,\n\t\tcrlf?: boolean,\n\t\tcr?: boolean,\n\t}\n}\n\nexport function crlf(text: string, newline: ILineBreakInput = EnumLineBreak.LF): string\n{\n\treturn text.replace(R_CRLF, newline);\n}\n\nexport function chkcrlf(text: string, options?: IOptions)\n{\n\tconst disable = options?.disable ?? {};\n\n\treturn {\n\t\tlf: !disable.lf && /\\n/.test(text.replace(/\\r\\n/g, '')),\n\t\tcrlf: !disable.crlf && /\\r\\n/.test(text),\n\t\tcr: !disable.cr && /\\r(?!\\n)/.test(text),\n\t} as const;\n}\n\nexport type IChkCrlf = ReturnType<typeof chkcrlf>;\n\nexport function detectLineBreak(text: string, options?: IOptions)\n{\n\tconst _lb = chkcrlf(text, options);\n\treturn _detectLineBreakCore(_lb)\n}\n\nexport function _detectLineBreakCore(_lb: IChkCrlf)\n{\n\treturn _lb.crlf ? EnumLineBreak.CRLF : (_lb.lf || !_lb.cr) ? EnumLineBreak.LF : EnumLineBreak.CR\n}\n\nexport function isCRLF(newline: string): newline is EnumLineBreak.CRLF\n{\n\treturn newline === EnumLineBreak.CRLF\n}\n\nexport function isLF(newline: string): newline is EnumLineBreak.LF\n{\n\treturn newline === EnumLineBreak.LF\n}\n\nexport function isCR(newline: string): newline is EnumLineBreak.CR\n{\n\treturn newline === EnumLineBreak.CR\n}\n\nexport function charCodeIsLF(charCode: number): charCode is EnumLineBreakCharCode.LF\n{\n\treturn charCode === EnumLineBreakCharCode.LF\n}\n\nexport function charCodeIsCR(charCode: number): charCode is EnumLineBreakCharCode.CR\n{\n\treturn charCode === EnumLineBreakCharCode.CR\n}\n\nexport function lineSplit(text: string)\n{\n\treturn text.split(R_CRLF);\n}\n\nexport function crlf_unicode_normalize(text: string, newline: ILineBreakInput = EnumLineBreak.LF): string\n{\n\tconst ln3 = newline + newline + newline;\n\tconst ln2 = newline + newline;\n\n\treturn text\n\t\t.replace(/\\u000C/g, ln3)\n\t\t.replace(/\\u2028/g, newline)\n\t\t.replace(/\\u2029/g, ln2)\n\t\t;\n}\n\nexport function isEqualWithIgnoreLineSeparators(a: string, b: string)\n{\n\tconst _lb_a: IChkCrlf = chkcrlf(a);\n\tconst _lb_b: IChkCrlf = chkcrlf(b);\n\n\tlet bool = false;\n\n\tif (_lb_a.cr === _lb_b.cr && _lb_a.crlf === _lb_b.crlf && _lb_a.lf === _lb_b.lf)\n\t{\n\t\tbool = crlf(a) === crlf(b);\n\t}\n\n\treturn {\n\t\tbool,\n\t\t_lb_a,\n\t\t_lb_b,\n\t}\n}\n\nexport type ILineBreakName = keyof typeof EnumLineBreak;\n\nexport function toLineBreakName(newline: ILineBreakInput): ILineBreakName\n{\n\tswitch (newline)\n\t{\n\t\tcase EnumLineBreak.LF:\n\t\t\treturn 'LF'\n\t\tcase EnumLineBreak.CR:\n\t\t\treturn 'CR'\n\t\tcase EnumLineBreak.CRLF:\n\t\t\treturn 'CRLF'\n\t}\n\n\tthrow new TypeError(`Invalid line break`);\n}\n\nexport function nameToLineBreak(name: ILineBreakName | Lowercase<ILineBreakName> | Capitalize<Lowercase<ILineBreakName>> | string): EnumLineBreak\n{\n\tswitch (name?.toUpperCase())\n\t{\n\t\tcase 'LF':\n\t\t\treturn EnumLineBreak.LF\n\t\tcase 'CR':\n\t\t\treturn EnumLineBreak.CR\n\t\tcase 'CRLF':\n\t\t\treturn EnumLineBreak.CRLF\n\t}\n\n\tthrow new TypeError(`Invalid line break name: ${name}`);\n}\n\nexport function detectCurrentIndexLineBreakFromBufferLike<T extends number, A extends {\n\t[n: number]: number\n}>(buffer: A, index: T)\n{\n\tconst cur = buffer[index];\n\tconst next = index + 1;\n\tif (charCodeIsLF(cur))\n\t{\n\t\treturn {\n\t\t\tnewline: EnumLineBreak.LF as const,\n\t\t\tcur: cur as EnumLineBreakCharCode.LF,\n\t\t\tindex,\n\t\t\tnext,\n\t\t\tlength: 1 as const,\n\t\t} as const\n\t}\n\telse if (charCodeIsCR(cur))\n\t{\n\t\tif (charCodeIsLF(buffer[next]))\n\t\t{\n\t\t\treturn {\n\t\t\t\tnewline: EnumLineBreak.CRLF as const,\n\t\t\t\tcur: cur as EnumLineBreakCharCode.CR,\n\t\t\t\tindex,\n\t\t\t\tnext: next + 1,\n\t\t\t\tlength: 2 as const,\n\t\t\t} as const\n\t\t}\n\n\t\treturn {\n\t\t\tnewline: EnumLineBreak.CR as const,\n\t\t\tcur: cur as EnumLineBreakCharCode.CR,\n\t\t\tindex,\n\t\t\tnext,\n\t\t\tlength: 1 as const,\n\t\t} as const\n\t}\n\n\treturn {\n\t\tnewline: void 0 as undefined,\n\t\tcur,\n\t\tindex,\n\t\tnext,\n\t\tlength: 0 as const,\n\t} as const\n}\n\nexport function detectCurrentIndexLineBreak<T extends number, A extends {\n\t[n: number]: string\n}>(buffer: A, index: T)\n{\n\tconst cur = buffer[index];\n\tconst next = index + 1;\n\tif (isLF(cur))\n\t{\n\t\treturn {\n\t\t\tnewline: EnumLineBreak.LF as const,\n\t\t\tcur: cur as EnumLineBreak.LF,\n\t\t\tindex,\n\t\t\tnext,\n\t\t\tlength: 1 as const,\n\t\t} as const\n\t}\n\telse if (isCR(cur))\n\t{\n\t\tif (isLF(buffer[next]))\n\t\t{\n\t\t\treturn {\n\t\t\t\tnewline: EnumLineBreak.CRLF as const,\n\t\t\t\tcur: cur as EnumLineBreak.CR,\n\t\t\t\tindex,\n\t\t\t\tnext: next + 1,\n\t\t\t\tlength: 2 as const,\n\t\t\t} as const\n\t\t}\n\n\t\treturn {\n\t\t\tnewline: EnumLineBreak.CR as const,\n\t\t\tcur: cur as EnumLineBreak.CR,\n\t\t\tindex,\n\t\t\tnext,\n\t\t\tlength: 1 as const,\n\t\t} as const\n\t}\n\n\treturn {\n\t\tnewline: void 0 as void,\n\t\tcur,\n\t\tindex,\n\t\tnext,\n\t\tlength: 0 as const,\n\t} as const\n}\n\nexport default crlf;\n"],"names":["EnumLineBreak","EnumLineBreakCharCode","exports","CR","R_CRLF","R_CRLF_MATCH","RegExp","source","flags","crlf","text","newline","replace","chkcrlf","options","_options$disable","disable","lf","test","cr","_detectLineBreakCore","_lb","isLF","isCR","charCodeIsLF","charCode","charCodeIsCR","crlf_unicode_normalize","ln2","detectCurrentIndexLineBreak","buffer","index","cur","next","length","detectCurrentIndexLineBreakFromBufferLike","detectLineBreak","isCRLF","isEqualWithIgnoreLineSeparators","a","b","_lb_a","_lb_b","bool","lineSplit","split","nameToLineBreak","name","toUpperCase","TypeError","toLineBreakName"],"mappings":"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"}