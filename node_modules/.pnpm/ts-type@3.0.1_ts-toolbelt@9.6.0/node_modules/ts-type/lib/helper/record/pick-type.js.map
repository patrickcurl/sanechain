{"version":3,"file":"pick-type.js","sourceRoot":"","sources":["pick-type.ts"],"names":[],"mappings":"","sourcesContent":["/**\n * @see https://github.com/type-challenges/type-challenges/blob/master/questions/2595-medium-pickbytype/README.md\n * @see https://github.com/type-challenges/type-challenges/issues/3814\n */\nimport { ITSNullPrimitive } from '../../type/base';\nimport { ITSValueOf } from '../key-value';\nimport { ITSExclude2, ITSExtract2 } from '../filter';\n\nexport type ITSKeyofByExtractType<T extends Record<keyof any, any>, U, K extends keyof T = keyof T> = K extends keyof T ? T[K] extends U ? K : never : never;\n\n/**\n * @see https://github.com/type-challenges/type-challenges/blob/master/questions/2595-medium-pickbytype/README.md\n * @see https://github.com/type-challenges/type-challenges/issues/3814\n */\nexport type ITSKeyofByExcludeType<T extends Record<keyof any, any>, U, K extends keyof T = keyof T> = K extends keyof T ? T[K] extends U ? never : K : never;\n\n/**\n * From `T`, pick a set of properties whose type are assignable to `U`.\n *\n * @example\ntype OmitBoolean = ITSPickByType<{\n  name: string\n  count: number\n  isReadonly: boolean\n  isEnable: boolean\n}, boolean>\n *\n * @see https://github.com/type-challenges/type-challenges/blob/master/questions/2595-medium-pickbytype/README.md\n * @see https://github.com/type-challenges/type-challenges/issues/3814\n */\nexport type ITSPickByType<T extends Record<keyof any, any>, U, K extends keyof T = keyof T> = {\n  [P in ITSKeyofByExtractType<T, U, K>]: T[P]\n}\n\n/**\n * From `T`, pick a set of properties whose type are not assignable to `U`.\n *\n * @example\ntype OmitBoolean = ITSOmitByType<{\n  name: string\n  count: number\n  isReadonly: boolean\n  isEnable: boolean\n}, boolean>\n *\n * @see https://github.com/type-challenges/type-challenges/blob/master/questions/2595-medium-pickbytype/README.md\n * @see https://github.com/type-challenges/type-challenges/issues/3814\n */\nexport type ITSOmitByType<T extends Record<keyof any, any>, U, K extends keyof T = keyof T> = {\n  [P in ITSKeyofByExcludeType<T, U, K>]: T[P]\n}\n\n/**\n * @internal\n */\nexport type ITSRecordExcludeToKey<Base, Type> = {\n  [Key in keyof Base]: ITSExclude2<Base[Key], Type, Key>\n};\n/**\n * @internal\n */\nexport type ITSRecordExtractToKey<Base, Type> = {\n  [Key in keyof Base]: ITSExtract2<Base[Key], Type, Key>\n};\n\nexport type ITSKeyOfRecordExcludeToKey<Base, Type> = ITSValueOf<ITSRecordExcludeToKey<Base, Type>>;\nexport type ITSKeyOfRecordExtractToKey<Base, Type> = ITSValueOf<ITSRecordExtractToKey<Base, Type>>;\n\nexport type ITSPickRecordType<Base, Type> = Pick<Base, ITSKeyOfRecordExtractToKey<Base, Type>>;\nexport type ITSOmitRecordType<Base, Type> = Pick<Base, ITSKeyOfRecordExcludeToKey<Base, Type>>;\n\n/**\n * @deprecated use `ITSPickByType<M, T, K>`\n */\nexport type ITSExtractRecord<M, T, K extends keyof M = keyof M> = ITSPickByType<M, T, K>\n\nexport type ITSExtractRecordNoNull<M, T, K extends keyof M = keyof M> = {\n  [P in K]: NonNullable<M[P]>;\n};\n\n/**\n * @deprecated use `ITSOmitByType<M, T, K>`\n */\nexport type ITSExcludeRecord<M, T, K extends keyof M = keyof M> = ITSOmitByType<M, T, K>;\n\nexport type ITSExcludeRecordNoNull<M, T, K extends keyof M = keyof M> = ITSOmitByType<M, ITSNullPrimitive, K>;\n\n/**\n * @deprecated use `ITSKeyofByExtractType<T, U, K>`\n */\nexport type ITSExtractKeyofRecord<M, T, K extends keyof M = keyof M> = ITSKeyofByExtractType<M, T, K>;\n\n/**\n * @deprecated use `ITSKeyofByExcludeType<M, T, K>`\n */\nexport type ITSExcludeKeyofRecord<M, T, K extends keyof M = keyof M> = ITSKeyofByExcludeType<M, T, K>;\n"]}